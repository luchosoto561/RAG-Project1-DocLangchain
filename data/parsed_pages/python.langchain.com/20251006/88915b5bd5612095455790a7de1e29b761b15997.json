{
  "provenance": {
    "url_final": "https://python.langchain.com/docs/how_to/extraction_parse/",
    "title": "How to use prompting alone (no tool calling) to do extraction | ðŸ¦œï¸ðŸ”— LangChain",
    "fetched_at": "2025-10-06T21:55:39.697399"
  },
  "sections": [
    {
      "level": 1,
      "heading_text": "How to use prompting alone (no tool calling) to do extraction | ðŸ¦œï¸ðŸ”— LangChain",
      "blocks": [
        {
          "type": "paragraph",
          "text": "Tool calling features are not required for generating structured output from LLMs. LLMs that are able to follow prompt instructions well can be tasked with outputting information in a given format."
        },
        {
          "type": "paragraph",
          "text": "This approach relies on designing good prompts and then parsing the output of the LLMs to make them extract information well."
        },
        {
          "type": "paragraph",
          "text": "To extract data without tool-calling features:"
        },
        {
          "type": "list",
          "ordered": true,
          "items": [
            "Instruct the LLM to generate text following an expected format (e.g., JSON with a certain schema);",
            "Use output parsers to structure the model response into a desired Python object."
          ]
        },
        {
          "type": "paragraph",
          "text": "First we select a LLM:"
        },
        {
          "type": "code",
          "code": "pip install -qU \"langchain[google-genai]\""
        },
        {
          "type": "code",
          "code": "import getpassimport osif not os.environ.get(\"GOOGLE_API_KEY\"):  os.environ[\"GOOGLE_API_KEY\"] = getpass.getpass(\"Enter API key for Google Gemini: \")from langchain.chat_models import init_chat_modelmodel = init_chat_model(\"gemini-2.5-flash\", model_provider=\"google_genai\")"
        },
        {
          "type": "paragraph",
          "text": "This tutorial is meant to be simple, but generally should really include reference examples to squeeze out performance!"
        }
      ],
      "children": [
        {
          "level": 2,
          "heading_text": "Using PydanticOutputParserâ€‹",
          "anchor": "using-pydanticoutputparser",
          "blocks": [
            {
              "type": "paragraph",
              "text": "The following example uses the built-in PydanticOutputParser to parse the output of a chat model."
            },
            {
              "type": "code",
              "code": "from typing import List, Optionalfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Field, validatorclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Set up a parserparser = PydanticOutputParser(pydantic_object=People)# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Wrap the output in `json` tags\\n{format_instructions}\",        ),        (\"human\", \"{query}\"),    ]).partial(format_instructions=parser.get_format_instructions())"
            },
            {
              "type": "paragraph",
              "text": "Let's take a look at what information is sent to the model"
            },
            {
              "type": "code",
              "code": "query = \"Anna is 23 years old and she is 6 feet tall\""
            },
            {
              "type": "code",
              "code": "print(prompt.format_prompt(query=query).to_string())"
            },
            {
              "type": "code",
              "code": "System: Answer the user query. Wrap the output in `json` tagsThe output should be formatted as a JSON instance that conforms to the JSON schema below.As an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}the object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.Here is the output schema:\\`\\`\\`{\"$defs\": {\"Person\": {\"description\": \"Information about a person.\", \"properties\": {\"name\": {\"description\": \"The name of the person\", \"title\": \"Name\", \"type\": \"string\"}, \"height_in_meters\": {\"description\": \"The height of the person expressed in meters.\", \"title\": \"Height In Meters\", \"type\": \"number\"}}, \"required\": [\"name\", \"height_in_meters\"], \"title\": \"Person\", \"type\": \"object\"}}, \"description\": \"Identifying information about all people in a text.\", \"properties\": {\"people\": {\"items\": {\"$ref\": \"#/$defs/Person\"}, \"title\": \"People\", \"type\": \"array\"}}, \"required\": [\"people\"]}\\`\\`\\`Human: Anna is 23 years old and she is 6 feet tall"
            },
            {
              "type": "paragraph",
              "text": "Having defined our prompt, we simply chain together the prompt, model and output parser:"
            },
            {
              "type": "code",
              "code": "chain = prompt | model | parserchain.invoke({\"query\": query})"
            },
            {
              "type": "code",
              "code": "People(people=[Person(name='Anna', height_in_meters=1.8288)])"
            },
            {
              "type": "paragraph",
              "text": "Check out the associated Langsmith trace."
            },
            {
              "type": "paragraph",
              "text": "Note that the schema shows up in two places:"
            },
            {
              "type": "list",
              "ordered": true,
              "items": [
                "In the prompt, via parser.get_format_instructions();",
                "In the chain, to receive the formatted output and structure it into a Python object (in this case, the Pydantic object People)."
              ]
            }
          ],
          "children": []
        },
        {
          "level": 2,
          "heading_text": "Custom Parsingâ€‹",
          "anchor": "custom-parsing",
          "blocks": [
            {
              "type": "paragraph",
              "text": "If desired, it's easy to create a custom prompt and parser with LangChain and LCEL."
            },
            {
              "type": "paragraph",
              "text": "To create a custom parser, define a function to parse the output from the model (typically an AIMessage) into an object of your choice."
            },
            {
              "type": "paragraph",
              "text": "See below for a simple implementation of a JSON parser."
            },
            {
              "type": "code",
              "code": "import jsonimport refrom typing import List, Optionalfrom langchain_anthropic.chat_models import ChatAnthropicfrom langchain_core.messages import AIMessagefrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Field, validatorclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Output your answer as JSON that  \"            \"matches the given schema: \\`\\`\\`json\\n{schema}\\n\\`\\`\\`. \"            \"Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tags\",        ),        (\"human\", \"{query}\"),    ]).partial(schema=People.schema())# Custom parserdef extract_json(message: AIMessage) -> List[dict]:    \"\"\"Extracts JSON content from a string where JSON is embedded between \\`\\`\\`json and \\`\\`\\` tags.    Parameters:        text (str): The text containing the JSON content.    Returns:        list: A list of extracted JSON strings.    \"\"\"    text = message.content    # Define the regular expression pattern to match JSON blocks    pattern = r\"\\`\\`\\`json(.*?)\\`\\`\\`\"    # Find all non-overlapping matches of the pattern in the string    matches = re.findall(pattern, text, re.DOTALL)    # Return the list of matched JSON strings, stripping any leading or trailing whitespace    try:        return [json.loads(match.strip()) for match in matches]    except Exception:        raise ValueError(f\"Failed to parse: {message}\")"
            },
            {
              "type": "code",
              "code": "query = \"Anna is 23 years old and she is 6 feet tall\"print(prompt.format_prompt(query=query).to_string())"
            },
            {
              "type": "code",
              "code": "System: Answer the user query. Output your answer as JSON that  matches the given schema: \\`\\`\\`json{'$defs': {'Person': {'description': 'Information about a person.', 'properties': {'name': {'description': 'The name of the person', 'title': 'Name', 'type': 'string'}, 'height_in_meters': {'description': 'The height of the person expressed in meters.', 'title': 'Height In Meters', 'type': 'number'}}, 'required': ['name', 'height_in_meters'], 'title': 'Person', 'type': 'object'}}, 'description': 'Identifying information about all people in a text.', 'properties': {'people': {'items': {'$ref': '#/$defs/Person'}, 'title': 'People', 'type': 'array'}}, 'required': ['people'], 'title': 'People', 'type': 'object'}\\`\\`\\`. Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tagsHuman: Anna is 23 years old and she is 6 feet tall"
            },
            {
              "type": "code",
              "code": "chain = prompt | model | extract_jsonchain.invoke({\"query\": query})"
            },
            {
              "type": "code",
              "code": "[{'people': [{'name': 'Anna', 'height_in_meters': 1.83}]}]"
            }
          ],
          "children": []
        },
        {
          "level": 2,
          "heading_text": "Other Librariesâ€‹",
          "anchor": "other-libraries",
          "blocks": [
            {
              "type": "paragraph",
              "text": "If you're looking at extracting using a parsing approach, check out the Kor library. It's written by one of the LangChain maintainers and it helps to craft a prompt that takes examples into account, allows controlling formats (e.g., JSON or CSV) and expresses the schema in TypeScript. It seems to work pretty!"
            },
            {
              "type": "list",
              "ordered": false,
              "items": [
                "Using PydanticOutputParser",
                "Custom Parsing",
                "Other Libraries"
              ]
            }
          ],
          "children": []
        }
      ]
    }
  ]
}