{
  "provenance": {
    "url_final": "https://python.langchain.com/docs/how_to/document_loader_custom/",
    "title": "Custom Document Loader | 🦜️🔗 LangChain",
    "fetched_at": "2025-10-06T21:54:53.753256"
  },
  "sections": [
    {
      "level": 2,
      "heading_text": "Overview​",
      "anchor": "overview",
      "blocks": [
        {
          "type": "paragraph",
          "text": "Applications based on LLMs frequently entail extracting data from databases or files, like PDFs, and converting it into a format that LLMs can utilize. In LangChain, this usually involves creating Document objects, which encapsulate the extracted text (page_content) along with metadata—a dictionary containing details about the document, such as the author's name or the date of publication."
        },
        {
          "type": "paragraph",
          "text": "Document objects are often formatted into prompts that are fed into an LLM, allowing the LLM to use the information in the Document to generate a desired response (e.g., summarizing the document). Documents can be either used immediately or indexed into a vectorstore for future retrieval and use."
        },
        {
          "type": "paragraph",
          "text": "The main abstractions for Document Loading are:"
        },
        {
          "type": "paragraph",
          "text": "This guide will demonstrate how to write custom document loading and file parsing logic; specifically, we'll see how to:"
        },
        {
          "type": "list",
          "ordered": true,
          "items": [
            "Create a standard document Loader by sub-classing from BaseLoader.",
            "Create a parser using BaseBlobParser and use it in conjunction with Blob and BlobLoaders. This is useful primarily when working with files."
          ]
        }
      ],
      "children": []
    },
    {
      "level": 2,
      "heading_text": "Standard Document Loader​",
      "anchor": "standard-document-loader",
      "blocks": [
        {
          "type": "paragraph",
          "text": "A document loader can be implemented by sub-classing from a BaseLoader which provides a standard interface for loading documents."
        }
      ],
      "children": [
        {
          "level": 3,
          "heading_text": "Interface​",
          "anchor": "interface",
          "blocks": [
            {
              "type": "list",
              "ordered": false,
              "items": [
                "The load methods is a convenience method meant solely for prototyping work -- it just invokes list(self.lazy_load()).",
                "The alazy_load has a default implementation that will delegate to lazy_load. If you're using async, we recommend overriding the default implementation and providing a native async implementation."
              ]
            },
            {
              "type": "paragraph",
              "text": "When implementing a document loader do NOT provide parameters via the lazy_load or alazy_load methods."
            },
            {
              "type": "paragraph",
              "text": "All configuration is expected to be passed through the initializer (init). This was a design choice made by LangChain to make sure that once a document loader has been instantiated it has all the information needed to load documents."
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Installation​",
          "anchor": "installation",
          "blocks": [
            {
              "type": "paragraph",
              "text": "Install langchain-core and langchain_community."
            },
            {
              "type": "code",
              "code": "%pip install -qU langchain_core langchain_community"
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Implementation​",
          "anchor": "implementation",
          "blocks": [
            {
              "type": "paragraph",
              "text": "Let's create an example of a standard document loader that loads a file and creates a document from each line in the file."
            },
            {
              "type": "code",
              "code": "from typing import AsyncIterator, Iteratorfrom langchain_core.document_loaders import BaseLoaderfrom langchain_core.documents import Documentclass CustomDocumentLoader(BaseLoader):    \"\"\"An example document loader that reads a file line by line.\"\"\"    def __init__(self, file_path: str) -> None:        \"\"\"Initialize the loader with a file path.        Args:            file_path: The path to the file to load.        \"\"\"        self.file_path = file_path    def lazy_load(self) -> Iterator[Document]:  # <-- Does not take any arguments        \"\"\"A lazy loader that reads a file line by line.        When you're implementing lazy load methods, you should use a generator        to yield documents one by one.        \"\"\"        with open(self.file_path, encoding=\"utf-8\") as f:            line_number = 0            for line in f:                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": self.file_path},                )                line_number += 1    # alazy_load is OPTIONAL.    # If you leave out the implementation, a default implementation which delegates to lazy_load will be used!    async def alazy_load(        self,    ) -> AsyncIterator[Document]:  # <-- Does not take any arguments        \"\"\"An async lazy loader that reads a file line by line.\"\"\"        # Requires aiofiles        # https://github.com/Tinche/aiofiles        import aiofiles        async with aiofiles.open(self.file_path, encoding=\"utf-8\") as f:            line_number = 0            async for line in f:                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": self.file_path},                )                line_number += 1"
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Test 🧪​",
          "anchor": "test-",
          "blocks": [
            {
              "type": "paragraph",
              "text": "To test out the document loader, we need a file with some quality content."
            },
            {
              "type": "code",
              "code": "with open(\"./meow.txt\", \"w\", encoding=\"utf-8\") as f:    quality_content = \"meow meow🐱 \\n meow meow🐱 \\n meow😻😻\"    f.write(quality_content)loader = CustomDocumentLoader(\"./meow.txt\")"
            },
            {
              "type": "code",
              "code": "%pip install -q aiofiles"
            },
            {
              "type": "code",
              "code": "## Test out the lazy load interfacefor doc in loader.lazy_load():    print()    print(type(doc))    print(doc)"
            },
            {
              "type": "code",
              "code": "<class 'langchain_core.documents.base.Document'>page_content='meow meow🐱 ' metadata={'line_number': 0, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow meow🐱 ' metadata={'line_number': 1, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow😻😻' metadata={'line_number': 2, 'source': './meow.txt'}"
            },
            {
              "type": "code",
              "code": "## Test out the async implementationasync for doc in loader.alazy_load():    print()    print(type(doc))    print(doc)"
            },
            {
              "type": "code",
              "code": "<class 'langchain_core.documents.base.Document'>page_content='meow meow🐱 ' metadata={'line_number': 0, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow meow🐱 ' metadata={'line_number': 1, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow😻😻' metadata={'line_number': 2, 'source': './meow.txt'}"
            },
            {
              "type": "paragraph",
              "text": "load() can be helpful in an interactive environment such as a jupyter notebook."
            },
            {
              "type": "paragraph",
              "text": "Avoid using it for production code since eager loading assumes that all the content can fit into memory, which is not always the case, especially for enterprise data."
            },
            {
              "type": "code",
              "code": "loader.load()"
            },
            {
              "type": "code",
              "code": "[Document(metadata={'line_number': 0, 'source': './meow.txt'}, page_content='meow meow🐱 \\n'), Document(metadata={'line_number': 1, 'source': './meow.txt'}, page_content=' meow meow🐱 \\n'), Document(metadata={'line_number': 2, 'source': './meow.txt'}, page_content=' meow😻😻')]"
            }
          ],
          "children": []
        }
      ]
    },
    {
      "level": 2,
      "heading_text": "Working with Files​",
      "anchor": "working-with-files",
      "blocks": [
        {
          "type": "paragraph",
          "text": "Many document loaders involve parsing files. The difference between such loaders usually stems from how the file is parsed, rather than how the file is loaded. For example, you can use open to read the binary content of either a PDF or a markdown file, but you need different parsing logic to convert that binary data into text."
        },
        {
          "type": "paragraph",
          "text": "As a result, it can be helpful to decouple the parsing logic from the loading logic, which makes it easier to re-use a given parser regardless of how the data was loaded."
        }
      ],
      "children": [
        {
          "level": 3,
          "heading_text": "BaseBlobParser​",
          "anchor": "baseblobparser",
          "blocks": [
            {
              "type": "paragraph",
              "text": "A BaseBlobParser is an interface that accepts a blob and outputs a list of Document objects. A blob is a representation of data that lives either in memory or in a file. LangChain python has a Blob primitive which is inspired by the Blob WebAPI spec."
            },
            {
              "type": "code",
              "code": "from langchain_core.document_loaders import BaseBlobParser, Blobclass MyParser(BaseBlobParser):    \"\"\"A simple parser that creates a document from each line.\"\"\"    def lazy_parse(self, blob: Blob) -> Iterator[Document]:        \"\"\"Parse a blob into a document line by line.\"\"\"        line_number = 0        with blob.as_bytes_io() as f:            for line in f:                line_number += 1                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": blob.source},                )"
            },
            {
              "type": "code",
              "code": "blob = Blob.from_path(\"./meow.txt\")parser = MyParser()"
            },
            {
              "type": "code",
              "code": "list(parser.lazy_parse(blob))"
            },
            {
              "type": "code",
              "code": "[Document(metadata={'line_number': 1, 'source': './meow.txt'}, page_content='meow meow🐱 \\n'), Document(metadata={'line_number': 2, 'source': './meow.txt'}, page_content=' meow meow🐱 \\n'), Document(metadata={'line_number': 3, 'source': './meow.txt'}, page_content=' meow😻😻')]"
            },
            {
              "type": "paragraph",
              "text": "Using the blob API also allows one to load content directly from memory without having to read it from a file!"
            },
            {
              "type": "code",
              "code": "blob = Blob(data=b\"some data from memory\\nmeow\")list(parser.lazy_parse(blob))"
            },
            {
              "type": "code",
              "code": "[Document(metadata={'line_number': 1, 'source': None}, page_content='some data from memory\\n'), Document(metadata={'line_number': 2, 'source': None}, page_content='meow')]"
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Blob​",
          "anchor": "blob",
          "blocks": [
            {
              "type": "paragraph",
              "text": "Let's take a quick look through some of the Blob API."
            },
            {
              "type": "code",
              "code": "blob = Blob.from_path(\"./meow.txt\", metadata={\"foo\": \"bar\"})"
            },
            {
              "type": "code",
              "code": "blob.encoding"
            },
            {
              "type": "code",
              "code": "'utf-8'"
            },
            {
              "type": "code",
              "code": "blob.as_bytes()"
            },
            {
              "type": "code",
              "code": "b'meow meow\\xf0\\x9f\\x90\\xb1 \\n meow meow\\xf0\\x9f\\x90\\xb1 \\n meow\\xf0\\x9f\\x98\\xbb\\xf0\\x9f\\x98\\xbb'"
            },
            {
              "type": "code",
              "code": "blob.as_string()"
            },
            {
              "type": "code",
              "code": "'meow meow🐱 \\n meow meow🐱 \\n meow😻😻'"
            },
            {
              "type": "code",
              "code": "blob.as_bytes_io()"
            },
            {
              "type": "code",
              "code": "<contextlib._GeneratorContextManager at 0x74b8d42e9940>"
            },
            {
              "type": "code",
              "code": "blob.metadata"
            },
            {
              "type": "code",
              "code": "{'foo': 'bar'}"
            },
            {
              "type": "code",
              "code": "blob.source"
            },
            {
              "type": "code",
              "code": "'./meow.txt'"
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Blob Loaders​",
          "anchor": "blob-loaders",
          "blocks": [
            {
              "type": "paragraph",
              "text": "While a parser encapsulates the logic needed to parse binary data into documents, blob loaders encapsulate the logic that's necessary to load blobs from a given storage location."
            },
            {
              "type": "paragraph",
              "text": "At the moment, LangChain supports FileSystemBlobLoader and CloudBlobLoader."
            },
            {
              "type": "paragraph",
              "text": "You can use the FileSystemBlobLoader to load blobs and then use the parser to parse them."
            },
            {
              "type": "code",
              "code": "from langchain_community.document_loaders.blob_loaders import FileSystemBlobLoaderfilesystem_blob_loader = FileSystemBlobLoader(    path=\".\", glob=\"*.mdx\", show_progress=True)"
            },
            {
              "type": "code",
              "code": "%pip install -q tqdm"
            },
            {
              "type": "code",
              "code": "parser = MyParser()for blob in filesystem_blob_loader.yield_blobs():    for doc in parser.lazy_parse(blob):        print(doc)        break"
            },
            {
              "type": "paragraph",
              "text": "Or, you can use CloudBlobLoader to load blobs from a cloud storage location (Supports s3://, az://, gs://, file:// schemes)."
            },
            {
              "type": "code",
              "code": "%pip install -q 'cloudpathlib[s3]'"
            },
            {
              "type": "code",
              "code": "from cloudpathlib import S3Client, S3Pathfrom langchain_community.document_loaders.blob_loaders import CloudBlobLoaderclient = S3Client(no_sign_request=True)client.set_as_default_client()path = S3Path(    \"s3://bucket-01\", client=client)  # Supports s3://, az://, gs://, file:// schemes.cloud_loader = CloudBlobLoader(path, glob=\"**/*.pdf\", show_progress=True)for blob in cloud_loader.yield_blobs():    print(blob)"
            }
          ],
          "children": []
        },
        {
          "level": 3,
          "heading_text": "Generic Loader\u0000​",
          "anchor": "generic-loader",
          "blocks": [
            {
              "type": "paragraph",
              "text": "LangChain has a GenericLoader abstraction which composes a BlobLoader with a BaseBlobParser."
            },
            {
              "type": "paragraph",
              "text": "GenericLoader is meant to provide standardized classmethods that make it easy to use existing BlobLoader implementations. At the moment, the FileSystemBlobLoader and CloudBlobLoader are supported. See example below:"
            },
            {
              "type": "code",
              "code": "from langchain_community.document_loaders.generic import GenericLoadergeneric_loader_filesystem = GenericLoader(    blob_loader=filesystem_blob_loader, blob_parser=parser)for idx, doc in enumerate(generic_loader_filesystem.lazy_load()):    if idx < 5:        print(doc)print(\"... output truncated for demo purposes\")"
            },
            {
              "type": "code",
              "code": "100%|██████████| 7/7 [00:00<00:00, 1224.82it/s]``````outputpage_content='# Text embedding models' metadata={'line_number': 1, 'source': 'embed_text.mdx'}page_content='' metadata={'line_number': 2, 'source': 'embed_text.mdx'}page_content=':::info' metadata={'line_number': 3, 'source': 'embed_text.mdx'}page_content='Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.' metadata={'line_number': 4, 'source': 'embed_text.mdx'}page_content=':::' metadata={'line_number': 5, 'source': 'embed_text.mdx'}... output truncated for demo purposes"
            },
            {
              "type": "paragraph",
              "text": "If you really like creating classes, you can sub-class and create a class to encapsulate the logic together."
            },
            {
              "type": "paragraph",
              "text": "You can sub-class from this class to load content using an existing loader."
            },
            {
              "type": "code",
              "code": "from typing import Anyclass MyCustomLoader(GenericLoader):    @staticmethod    def get_parser(**kwargs: Any) -> BaseBlobParser:        \"\"\"Override this method to associate a default parser with the class.\"\"\"        return MyParser()"
            },
            {
              "type": "code",
              "code": "loader = MyCustomLoader.from_filesystem(path=\".\", glob=\"*.mdx\", show_progress=True)for idx, doc in enumerate(loader.lazy_load()):    if idx < 5:        print(doc)print(\"... output truncated for demo purposes\")"
            },
            {
              "type": "code",
              "code": "100%|██████████| 7/7 [00:00<00:00, 814.86it/s]``````outputpage_content='# Text embedding models' metadata={'line_number': 1, 'source': 'embed_text.mdx'}page_content='' metadata={'line_number': 2, 'source': 'embed_text.mdx'}page_content=':::info' metadata={'line_number': 3, 'source': 'embed_text.mdx'}page_content='Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.' metadata={'line_number': 4, 'source': 'embed_text.mdx'}page_content=':::' metadata={'line_number': 5, 'source': 'embed_text.mdx'}... output truncated for demo purposes"
            },
            {
              "type": "list",
              "ordered": false,
              "items": [
                "Interface",
                "Installation",
                "Implementation",
                "Test 🧪"
              ]
            },
            {
              "type": "list",
              "ordered": false,
              "items": [
                "BaseBlobParser",
                "Blob",
                "Blob Loaders",
                "Generic Loader"
              ]
            }
          ],
          "children": []
        }
      ]
    }
  ]
}