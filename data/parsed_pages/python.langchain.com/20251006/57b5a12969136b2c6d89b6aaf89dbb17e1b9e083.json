{
  "provenance": {
    "url_final": "https://python.langchain.com/docs/how_to/query_constructing_filters/",
    "title": "How to construct filters for query analysis | ü¶úÔ∏èüîó LangChain",
    "fetched_at": "2025-10-06T21:54:50.720785"
  },
  "sections": [
    {
      "level": 1,
      "heading_text": "How to construct filters for query analysis | ü¶úÔ∏èüîó LangChain",
      "blocks": [
        {
          "type": "paragraph",
          "text": "We may want to do query analysis to extract filters to pass into retrievers. One way we ask the LLM to represent these filters is as a Pydantic model. There is then the issue of converting that Pydantic model into a filter that can be passed into a retriever."
        },
        {
          "type": "paragraph",
          "text": "This can be done manually, but LangChain also provides some \"Translators\" that are able to translate from a common syntax into filters specific to each retriever. Here, we will cover how to use those translators."
        },
        {
          "type": "code",
          "code": "from typing import Optionalfrom langchain.chains.query_constructor.ir import (    Comparator,    Comparison,    Operation,    Operator,    StructuredQuery,)from langchain_community.query_constructors.chroma import ChromaTranslatorfrom langchain_community.query_constructors.elasticsearch import ElasticsearchTranslatorfrom pydantic import BaseModel"
        },
        {
          "type": "paragraph",
          "text": "In this example, year and author are both attributes to filter on."
        },
        {
          "type": "code",
          "code": "class Search(BaseModel):    query: str    start_year: Optional[int]    author: Optional[str]"
        },
        {
          "type": "code",
          "code": "search_query = Search(query=\"RAG\", start_year=2022, author=\"LangChain\")"
        },
        {
          "type": "code",
          "code": "def construct_comparisons(query: Search):    comparisons = []    if query.start_year is not None:        comparisons.append(            Comparison(                comparator=Comparator.GT,                attribute=\"start_year\",                value=query.start_year,            )        )    if query.author is not None:        comparisons.append(            Comparison(                comparator=Comparator.EQ,                attribute=\"author\",                value=query.author,            )        )    return comparisons"
        },
        {
          "type": "code",
          "code": "comparisons = construct_comparisons(search_query)"
        },
        {
          "type": "code",
          "code": "_filter = Operation(operator=Operator.AND, arguments=comparisons)"
        },
        {
          "type": "code",
          "code": "ElasticsearchTranslator().visit_operation(_filter)"
        },
        {
          "type": "code",
          "code": "{'bool': {'must': [{'range': {'metadata.start_year': {'gt': 2022}}},   {'term': {'metadata.author.keyword': 'LangChain'}}]}}"
        },
        {
          "type": "code",
          "code": "ChromaTranslator().visit_operation(_filter)"
        },
        {
          "type": "code",
          "code": "{'$and': [{'start_year': {'$gt': 2022}}, {'author': {'$eq': 'LangChain'}}]}"
        }
      ],
      "children": []
    }
  ]
}